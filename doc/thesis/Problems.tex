\section{Problem Description}
\label{sec:ProblemDescription}
\miniquote{
 n. 1.a: Agreement or logical coherence among things or parts.\ \ \ \ \\
     1.b: Correspondence among related aspects; compatibility.\ \ \ \ \\
 2: Reliability or uniformity of successive results or events.\ \ \ \ \\
           3: logical coherence and accordance with the facts;\ \ \ \ \\
                                           Dictionary.com/Consistency \\
                                                                    \ \\
}

This thesis mainly looks at the possible causes of inconsistent lookup,
 and will try to solve those through the mean of keeping the routing tables
 consistent with the state of the nodes in the DHT. The assumption is that
 inconsistent lookup is generated by inconsistent routing tables, and that
 if consistency can be guaranteed over scalability, then Distributed Hash Tables
 will be more attractive to commercial use.

\subsection{Lookup Consistency in a DHT}
\label{problem:ReliableLookup}

As stated in the Bamboo F.A.Q \cite{bamboo-homepage}, consistency in the
 DHT during heavy churn is only $95\%$. As this is the main topic of the
 thesis, we must first define what we mean by the term \qmark{consistent
 lookup}.

\subsubsection{Consistency and Reliability}

The term \qmark{consistency} is widely used in literature about database
 technology, but the four degrees of consistency described by Grey et
  al\cite{grey-75-consistency-locks} % pp 184-185, ADBS 2. artikkel.
 fall short of the \qmark{operational consistency} needed for the lookup
 procedure. But a rather simplified consistency rule is to always access the
 latest value put in the database, but the term is still too vague, and doesn't
 take into account the reliability of the system.

$\mathrm{\ddot{O}}$uzu and Valduries \cite{oszu-99-podds} describes reliability as \qmark{the
 probability that the system under consideration does not experience any
 failures in a given time interval}, and availability as \qmark{[...] the
 probability that the system is operational according to its specification at
 a given point in time [...]}. % OSZU-PODDS 12.1.2 pp 356-7

If we describe \qmark{lookup failure} as the situation where the given result
 is not consistent with any state of the DHT between the start and the end of
 the lookup procedure, then we can define specifically what we mean by
 \qmark{consistent lookup}.

\subsubsection{Defining \qmark{Consistent Lookup}}
\label{problem:DefiningConsistency}

We will first define \qmark{consistent lookup}, and later explore the consequences
 of this definition. The goal is to be able to trust a lookup result to
 give the actual \emph{state} of the DHT, and rather accept failed lookups than
 accepting the first result we can get.

It is clear that if a node does not exists in a DHT, then no node will pretend that
 it does. But we can work further with two failure scenarios. First is that there is
 inconsistent within the tables, that may return the \emph{wrong owner}. This in turn may
 lead to a node believing a node that is in the DHT not to be there (breaking rule
 \ref{enum:rule-A} of the rules outlined here and in Table
 \ref{tab:consistency-definition}).

{
\renewcommand{\theenumi}{{\em\Alph{enumi}}}
\begin{enumerate}
\item\label{enum:rule-A}
  The first rule states that if a node $\psi$ is the owner of
  an index $\tau$, and a data item of that key exists, then the
  only accepted lookup results are $\psi$ is owner of the tuple,
  or that the owner is not available.
\item\label{enum:rule-B}
  The second rule is rather stating that if a lookup gives a positive
  result, e.g. \qmark{the tuple sought for exists at the node $\psi$}, then
  node $\psi$ is the owner of the tuple (by index), and the tuple exist
  at that node.
\end{enumerate}
}

\begin{table}[htp]% Definition of Consistent Lookup
\begin{center}
\begin{tabular}{cc}
\begin{tabular}{|cc|l|}                                  \hline
 (1) &  -  & Tuple Availability States:               \\ \hline
  \  &$1 =$& Owner node is $\psi$.                    \\
  \  &$0 =$& Owner node is not available.             \\ \hline\hline
 (2) &  -  & Predicates:                              \\ \hline
  \  &$P_1$& $\psi\in\Delta\ \cap\ \rho\in\Delta $   \\
  \  &$P_2$& $\tau\in\Sigma\ $  \\
  \  &$P_3$& $\psi=\mathtt{owner\_of}(\tau)$ \\ \hline\hline
 (3) &  -  & Rules:                                                  \\ \hline
  \  &\ref{enum:rule-A}&
        $\bigcap_{i=1..3}\ P_i\ \Rightarrow\ \rho.\mathtt{lookup}(\tau)\in\{1,0\}$\\
  \  &\ref{enum:rule-B}&
        $\bigcap_{i=1..3}\ P_i\ \Leftarrow\  \rho.\mathtt{lookup}(\tau)\in\{1\}$  \\
  \hline
\end{tabular}

&

\parbox{.34\linewidth}{ \small
  The two \emph{availability states} suggests that either the owner node of the
  sought for index is known, and is $\rho$, or it is unknown, and therefor
  not available.

  The three predications is that first ($P_1$) $\rho$ and $\psi$ is nodes that
  \emph{both are members of the same DHT}, and second ($P_2$) that the index
  $\tau$ is in the index space ($\Sigma$), and subsequently ($P_3$) owned by
  the node $\psi$ according to the definition of ownership by the DHT.

}

\end{tabular}

\vspace*{.06cm}
\parbox{.9\linewidth}{ \small
  Lastly the two rules of consistency. Rule \ref{enum:rule-A} states that if the three
  predications are true; Member node $\psi$ of DHT $\Delta$ is the owner of the index
  $\tau$, and $\rho$ is a node in the same DHT executing the lookup; then the result
  is either that $\psi$ is the owner, or that the owner is
  unavailable. Rule \ref{enum:rule-B} states that if the lookup results proclaims
  that node $\psi$ is the owner of the index $\tau$, then that is true for DHT $\Delta$.
}

\end{center}
\caption{Definition of Consistent Lookup}
\label{tab:consistency-definition}
\end{table}


These rules make some implications on how consistency
 can be measured. Since consistency is not defined as consistent result among a group
 of queries, but as a reading of the \qmark{state} of the DHT,
 then consistency has to be checked against
 more information than the nodes, and to allow variations in simultaneous queries
 where it conscede with a state change.

The two scenarios of false positives and false negatives can be showed to
 break the consistency rules in Table \ref{tab:consistency-definition}. False positives
 will break rule \ref{enum:rule-B} by invalidating $P_1$ or $P_3$, and false negatives will break
 rule \ref{enum:rule-B} by returning the wrong state, thus invalidating $P_3$.

The separation of rule \ref{enum:rule-A} and rule \ref{enum:rule-B} is set
 there to allow for a negative response (e.g. unavailable owner node)
 as a consistent lookup restult.

\subsubsection{Defining Ownership}

In Section \ref{theory:Churn} there was a loss of a definition of what
 \emph{ownership} means in terms of an evolving DHT. So when does ownership
 begins, and when does it ends? It is possible to define it in relation
 to routing (the core cycle in Chord) or completed joining.

In terms of routing a node $n$ that \qmark{owns} some part
 $I_{n}\ \ldots\ I_{n+1}-1$ of the index space should have the property that
 ownership is not falsely given to any other node as long as that ownership
 is in place. This will ensure that from the moment lookups can be routed
 to a node, and until routing will not end there later, no other lookup will
 end up at another node.

To put this into a time frame, when does it start? If routing is the only
 definition of ownership, there may be severe difficulties defining what
 the correct owner is at a point in time ($t$). Nodes come and go, and nodes
 may get incorrect successors ($s_1$).

If ownership is defined by a \qmark{membership} protocol related to a
 pre-join and a post-join membership state, and defines it
 as the node is owner \emph{from the moment the join protocol is finished} and until
 \emph{the leave protocol is finished}. With this definition of membership, ownership
 and consistent lookup, we can take a look at how to get consistent lookups.

\subsection{Approaches}

There are several approaches to the problem of consistency. Three ways we have considered
 are \emph{algorithmic prevention}, a \emph{statistical prevention}
 and \emph{structural prevention}.

\subsubsection{Algorithmic Prevention}

Algorithmic prevention is to look at the lookup algorithm it self, and see if
 changes to it can improve consistency. One approach of this is to check a set of
 close neighbors to the possible owner node, and to a \emph{neighborhood check} on
 ownership.

It is possible to check a series of nodes in the same neighborhood to see if they
 agree who is the real owner of a given index. If a majority of the nodes, including
 the owner, agrees, then we can say the lookup is successfull. This can be implemented
 as a voting protocol over a set of nodes close to $\tau$, but this will require group
 access to these nodes, and this must be managed.

A problem with this protocol is the amount of lookup overhead needed. Each of the
 \qmark{voting} nodes must be contacted in addition with the owner node, and an agreement
 protocol (based on a centralized vote-commit-protocol as described by
 $\mathrm{\ddot{O}}$szu et al\cite{oszu-99-podds} (pp. 403--6).
 In addition to this, each node must use a group
 management protocol, to maintain a set of viable neighbors, or build on the spot a set
 of check-neighbors, that can verify each lookup. This adds significantly to the
 complexity of the lookup algorithm, and makes it not worth studying here.

\subsubsection{Statistical Prevention}

Simple statistics may also be used in securing the consistency of a lookup result.
 When doing a lookup, the DHT can do multiple lookups ($l_{mul}$) through different
 neighbors for the same index. When a minimal number of lookups
 ($l_{min}\geq\frac{l_{mul}}{2}$) are complete, they can be used as votes, and a
 majority (of $l_mul$) will yield a presumed consistent result, and no majority will result in
 a presumed inconsistent result, and marked as unsuccessfully.

This approach has its weaknesses. First each lookup will have significantly longer latency
 as the node has to wait for enough lookups to succeed. The second is additional
 network traffic, linearly increased with lookup count.
 The third is a result of failure persistence. If a lookup is inconsistent
 one time, it may likely happen again, even if different neighbors are used,
 making it more difficult to assume consistency.

\subsubsection{Structural Prevention}
\label{problem:AvoidingInconsistency}

In database terms \qmark{deadlock avoidance} is described as to \qmark{employ concurrency
 control techniques that will never result in deadlocks or require that schedulers
 detect potential deadlock situations in advance and ensure that they will never
 occur} \cite{oszu-99-podds}. The same way we can argue that \qmark{lookup
 inconsistency avoidance} is to \qmark{employ techniques that will never result in
 inconsistent lookups or require lookup managers to detect potential inconsistent lookup
 in advance and ensure that they will never occur}. Since inconsistency is more or less
 impossible to detect in advance, this will not be an option.

To detect inconsistent lookup in advance, we have to look at the routing tables, and
 see if there is a chance that the current tables will create possible inconsistent
 lookups. If we assume that \emph{inconsistent lookup is always a result of inconsistent
 routing tables}, and we can eliminate \emph{inconsistent routing tables},
 then we will eliminate inconsistent lookups.

In this approach there is hopefully no extra cost for lookups, but there may
 be other factors and there may be other side effects. This approach is seen
 as the most interesting to study as it may have the potential of eliminating
 inconsistent lookups altogether with the right assumptions.

\paragraph{Thesis Approach}
In this thesis we chose to use \emph{structural prevention}, as it has the
 potential of eliminating lookup inconsistency with no alteration to the
 lookup algorithms themself. It may have a cost, but it will not be explored
 here, as it is considerable work.

\subsection{Thesis Goals}
\label{problem:Goals}

The thesis is after this section divided in three parts. First we have an analysis
 of various failure
 scenarios that can result in inconsistent lookups, and how to avoid them. Then we
 will try to implements those ideas into a DHT based on the Chord\cite{stoica-01-chord}
 algorithm, and then we will see what can be moved on to the existing DHTs.

\subsubsection{Analysis Overview}
\label{problem:Goal:Analysis}

We will analyze different failure scenarios that may result in inconsistent lookups,
 including single link failures, node failures and such failures in concurrency with
 node joins and leaves. The solutions proposed is meant to be implementable in the
 project named \qmark{Accord} for testing and proof of concept, and is thus based on
 it's geometry and algorithms. The analysis is
 described in Section \ref{sec:Analysis}.

\subsubsection{Project Overview}
\label{problem:Goal:Project}

We will also implement a DHT based on the Chord algorithm, from scratch, that is to
 take advantage of the solutions proposed in the analysis. The design of the system
 is described in Section \ref{sec:Design}. Parts
 of the design and implementation were done prior to analysis, and limited time has put
 limitation on the completeness of the implementation.

\subsubsection{Discussion Overview}
\label{problem:Goal:Discussion}

After the analysis and implementation, we will discuss how the solutions found and
 developed in Accord can be used with existing DHTs to improve their consistency rating.

